{{- /* ASCII Background Animation Partial */ -}}
{{- /* Only show on home page to avoid performance impact on other pages */ -}}
{{- if .IsHome }}
<style>
  /* Ensure html and body don't overflow or offset */
  html, body {
    margin: 0;
    padding: 0;
    overflow-x: hidden;
    max-width: 100vw;
  }

  /* ASCII animation background - only visible on home page */
  #ascii-bg {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
    white-space: pre;
    line-height: 1;
    letter-spacing: 1px;
    font-variant-ligatures: none;
    z-index: 0; /* Behind all content */
    pointer-events: none; /* Allow clicks through to content */
    color: var(--ascii-color, rgba(98, 11, 11, 0.008)); /* More subtle/transparent */
    font-size: 12px; /* Base font size */
    font-family: monospace;
    overflow: hidden;
  }

  /* Dark mode uses lighter ASCII characters - subtle increase */
  .dark #ascii-bg {
    --ascii-color: rgba(255, 255, 255, 0.05);
  }

  /* Light mode uses darker ASCII characters - subtle increase */
  body:not(.dark) #ascii-bg {
    --ascii-color: rgba(0, 0, 0, 0.11);
  }

  /* Responsive font sizing */
  @media (max-width: 420px) {
    #ascii-bg {
      font-size: 10px;
    }
  }

  @media (min-width: 1920px) {
    #ascii-bg {
      font-size: 14px;
    }
  }
</style>

<!-- ASCII background container -->
<div id="ascii-bg" aria-hidden="true"></div>

<script>
  /**
   * ASCII Background Animation
   * Creates an animated ASCII art background
   *
   * Features:
   * - Fullscreen ASCII grid with radial wave patterns
   * - Responsive to window resize
   * - Performance optimized with single DOM write per frame
   */
  (function() {
    'use strict';

    const asciiEl = document.getElementById('ascii-bg');
    if (!asciiEl) return; // Exit if element doesn't exist

    // Get current date dynamically
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD format
    const dateChars = dateStr.split(''); // Split into individual characters

    // Character palette: subtle background characters for ambient animation
    // Includes "carlos nunez" and today's date for personalization
    const basePalette = [
      ' ', ' ', ' ', ' ', '.', '.', '.', ',', ',', '`', '\'', ':', ';', '-', '_', '~', '^', '"',
      '*', '+', '=', 'o', 'O', '0', '#', '%', '@', '¬', '÷', '×', '±', '≈', '≠',
      'c', 'a', 'r', 'l', 'o', 's', ' ', 'n', 'u', 'n', 'e', 'z',  // carlos nunez
      ...dateChars,  // Today's date dynamically
      '░', '▪', '▫', '•', '·', '∙', '◦', '○', '◉', '⋅', '∴', '∵', '⊕', '⊗', '⊙'
    ];

    // Grid dimensions
    let cols = 0;        // Number of columns in ASCII grid
    let rows = 0;        // Number of rows in ASCII grid
    let charW = 8;       // Width of each character in pixels
    let charH = 16;      // Height of each character in pixels

    // Animation state
    let frame = 0;       // Current animation frame counter

    /**
     * Measures the actual pixel dimensions of a monospace character
     * This ensures accurate grid calculations across different screen sizes
     */
    function measureChar() {
      const span = document.createElement('span');
      span.style.fontFamily = 'monospace';
      span.style.fontSize = window.getComputedStyle(asciiEl).fontSize || '12px';
      span.style.padding = '0';
      span.style.margin = '0';
      span.style.lineHeight = '1';
      span.textContent = 'M';
      span.style.position = 'absolute';
      span.style.visibility = 'hidden';
      document.body.appendChild(span);

      const rect = span.getBoundingClientRect();
      charW = Math.max(6, Math.ceil(rect.width));
      charH = Math.max(8, Math.ceil(rect.height));

      span.remove();
    }

    /**
     * Recalculates grid dimensions on window resize
     * Ensures the ASCII grid fills the viewport correctly with overflow to eliminate gaps
     */
    function resize() {
      measureChar();
      // Use ceil instead of floor and add 1 to ensure full coverage with overflow
      cols = Math.max(2, Math.ceil(window.innerWidth / charW) + 1);
      rows = Math.max(2, Math.ceil(window.innerHeight / charH) + 1);
    }

    // Initial setup
    resize();

    // Keep grid responsive to window size changes
    window.addEventListener('resize', resize);

    /**
     * Main animation loop
     * Renders the ASCII grid with animated patterns
     */
    function draw() {
      const out = [];

      // Build each row of the ASCII grid
      for (let y = 0; y < rows; y++) {
        const line = [];

        for (let x = 0; x < cols; x++) {
          // Normalize coordinates to -1..1 range for base animation
          const cHalfX = cols / 2;
          const cHalfY = rows / 2;
          const nx = (x - cHalfX) / cHalfX;
          const ny = (y - cHalfY) / cHalfY;

          // Create animated base pattern using radial waves and procedural noise
          const distCenter = Math.sqrt(nx * nx + ny * ny);
          const angle = Math.atan2(ny, nx);

          // Multiple wave layers for increased variation
          const radialWave1 = Math.sin(distCenter * 6.0 - frame * 0.06 + angle * 2.0);
          const radialWave2 = Math.cos(distCenter * 4.5 + frame * 0.04 - angle * 1.5);
          const radialWave3 = Math.sin(distCenter * 8.0 - frame * 0.08 + angle * 3.0);

          // Swirl patterns with different speeds
          const swirl1 = Math.cos(angle * 3.0 + frame * 0.02);
          const swirl2 = Math.sin(angle * 5.0 - frame * 0.03 + distCenter * 2.0);

          // Pulsing effects
          const pulse1 = Math.sin(frame * 0.04) * 0.12;
          const pulse2 = Math.cos(frame * 0.05 + distCenter * 3.0) * 0.15;

          // Procedural noise-like pattern
          const noise1 = Math.sin(x * 0.3 + frame * 0.02) * Math.cos(y * 0.2 - frame * 0.015);
          const noise2 = Math.cos(x * 0.15 - frame * 0.025) * Math.sin(y * 0.25 + frame * 0.02);

          // Diagonal wave patterns
          const diag1 = Math.sin((nx + ny) * 4.0 + frame * 0.03);
          const diag2 = Math.cos((nx - ny) * 3.5 - frame * 0.025);

          // Random temporal variation
          const temporal = Math.sin(frame * 0.01) * Math.cos(frame * 0.007);

          // Combine all patterns with varying weights for rich procedural complexity
          let v = radialWave1 * 0.4 +
                  radialWave2 * 0.25 +
                  radialWave3 * 0.15 +
                  swirl1 * 0.3 +
                  swirl2 * 0.2 +
                  pulse1 +
                  pulse2 +
                  noise1 * 0.35 +
                  noise2 * 0.25 +
                  diag1 * 0.2 +
                  diag2 * 0.15 +
                  temporal * 0.1;

          // Map wave value to 0..1 range
          const mapped = (v + 2) / 4;
          let idx = Math.floor(mapped * basePalette.length);

          // Add procedural randomness to character selection
          // Occasionally pick adjacent characters for organic variation
          if (Math.random() < 0.25) {
            idx += Math.floor((Math.random() - 0.5) * 3);
          }

          // Randomly select any character for additional chaos
          if (Math.random() < 0.08) {
            idx = Math.floor(Math.random() * basePalette.length);
          }

          idx = Math.max(0, Math.min(basePalette.length - 1, idx));
          line.push(basePalette[idx]);
        }

        out.push(line.join(''));
      }

      // Single DOM write per frame for optimal performance
      asciiEl.textContent = out.join('\n');

      frame++;
      requestAnimationFrame(draw);
    }

    // Start animation
    draw();
  })();
</script>
{{- end }}
